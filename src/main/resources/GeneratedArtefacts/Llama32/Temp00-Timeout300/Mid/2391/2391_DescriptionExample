package it.cnr.iasi.saks.llmPrompter.leetCodeDemo.gen;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class 2391_DescriptionExample {

    @Test
    public void test_1() {
        String[] garbage = {"G","P","GP","GG"};
        int[] travel = {2,4,3};
        assertEquals(21, minGarbagePickup(garbage, travel));
    }

    @Test
    public void test_2() {
        String[] garbage = {"MMM","PGM","GP"};
        int[] travel = {3,10};
        assertEquals(37, minGarbagePickup(garbage, travel));
    }

    @Test
    public void test_3() {
        String[] garbage = {"G","P","MP","GG"};
        int[] travel = {2,4,1,3};
        assertEquals(21, minGarbagePickup(garbage, travel));
    }

    @Test
    public void test_4() {
        String[] garbage = {"M","MP","PG","GG"};
        int[] travel = {1,2,3,4};
        assertEquals(25, minGarbagePickup(garbage, travel));
    }

    @Test
    public void test_5() {
        String[] garbage = {"G","P","GP","GG","M"};
        int[] travel = {2,4,3,1,10};
        assertEquals(37, minGarbagePickup(garbage, travel));
    }
    
    public int minGarbagePickup(String[] garbage, int[] travel) {
        int n = garbage.length;
        int[][] dp = new int[n][3];
        for (int i = 0; i < n; i++) {
            dp[i][0] = Integer.MAX_VALUE;
            dp[i][1] = Integer.MAX_VALUE;
            dp[i][2] = Integer.MAX_VALUE;
        }
        dp[0][0] = 0;
        dp[0][1] = travel[0];
        dp[0][2] = travel[0];

        for (int i = 1; i < n; i++) {
            int m = garbage[i].indexOf('M');
            int p = garbage[i].indexOf('P');
            int g = garbage[i].indexOf('G');

            for (int j = 0; j < 3; j++) {
                if (j == 0) dp[i][1] = Math.min(dp[i][1], dp[i - 1][2] + travel[i]);
                if (j == 1) dp[i][2] = Math.min(dp[i][2], dp[i - 1][0] + travel[i]);
                if (j == 2) dp[i][0] = Math.min(dp[i][0], dp[i - 1][1] + travel[i]);
            }

            for (int j = 0; j < 3; j++) {
                int cost;
                switch (j) {
                    case 0:
                        cost = m == -1 ? Integer.MAX_VALUE : m + 1;
                        break;
                    case 1:
                        cost = p == -1 ? Integer.MAX_VALUE : p + 1;
                        break;
                    default:
                        cost = g == -1 ? Integer.MAX_VALUE : g + 1;
                }
                dp[i][j] += cost;
            }
        }

        return Math.min(Math.min(dp[n - 1][0], dp[n - 1][1]), dp[n - 1][2]);
    }
}
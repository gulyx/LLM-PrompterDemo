package it.cnr.iasi.saks.llmPrompter.leetCodeDemo.gen;

import java.util.HashMap;
import java.util.Map;

public class DescriptionOnlyTest {

    public static void main(String[] args) {
        org.junit.runner.JUnitCore.main("1079_DescriptionOnlyTest");
    }

    @org.junit.Test
    public void test1() {
        int n = 2;
        String tiles = "ab";
        int expected = 2;
        int actual = numTilePossibilities(n, tiles);
        org.junit.Assert.assertEquals(expected, actual);
    }

    @org.junit.Test
    public void test2() {
        int n = 3;
        String tiles = "aab";
        int expected = 5;
        int actual = numTilePossibilities(n, tiles);
        org.junit.Assert.assertEquals(expected, actual);
    }

    @org.junit.Test
    public void test3() {
        int n = 4;
        String tiles = "abba";
        int expected = 14;
        int actual = numTilePossibilities(n, tiles);
        org.junit.Assert.assertEquals(expected, actual);
    }

    @org.junit.Test
    public void test4() {
        int n = 1;
        String tiles = "a";
        int expected = 1;
        int actual = numTilePossibilities(n, tiles);
        org.junit.Assert.assertEquals(expected, actual);
    }

    @org.junit.Test
    public void test5() {
        int n = 0;
        String tiles = "";
        int expected = 1;
        int actual = numTilePossibilities(n, tiles);
        org.junit.Assert.assertEquals(expected, actual);
    }
}

public class Solution {

    public static int numTilePossibilities(String tiles) {
        Map<Character, Integer> map = new HashMap<>();
        for (char c : tiles.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        return permute(map.values());
    }

    private static long permute(int[] nums) {
        if (nums.length == 0) {
            return 1;
        }
        long res = 0;
        for (int i = 0; i < nums.length; i++) {
            int n = nums[i];
            int m = nums.length - 1 - i;
            res += permute(java.util.Arrays.copyOfRange(nums, i + 1, nums.length)) * factorial(m) / factorial(n);
        }
        return res;
    }

    private static long factorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }
}
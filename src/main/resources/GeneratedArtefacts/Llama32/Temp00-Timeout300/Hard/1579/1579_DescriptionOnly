package it.cnr.iasi.saks.llmPrompter.leetCodeDemo.gen;

import org.junit.Test;
import static org.junit.Assert.*;

public class 1579_DescriptionOnlyTest {

    @Test
    public void test_0() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}};
        assertEquals(0, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_1() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}};
        assertEquals(2, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_2() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}};
        assertEquals(3, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_3() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13}};
        assertEquals(4, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_4() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13}, {14, 15, 16}};
        assertEquals(-1, maxNumEdgesToRemove(edges));
    }
}

int maxNumEdgesToRemove(int[][] edges) {
    int n = edges.length;
    boolean[] aliceVisited = new boolean[n];
    boolean[] bobVisited = new boolean[n];

    for (int i = 0; i < n; i++) {
        if (!aliceVisited[i]) {
            dfs(edges, aliceVisited, i);
        }
        if (!bobVisited[i]) {
            dfs(edges, bobVisited, i);
        }
    }

    int count = 0;
    boolean[] visited = new boolean[n];
    for (int i = 0; i < n; i++) {
        if (aliceVisited[i] && bobVisited[i]) {
            continue;
        } else if (aliceVisited[i]) {
            for (int j = 0; j < edges.length; j++) {
                if (edges[j][1] == i || edges[j][2] == i) {
                    visited[edges[j][1]] = true;
                    visited[edges[j][2]] = true;
                    count++;
                }
            }
        } else if (bobVisited[i]) {
            for (int j = 0; j < edges.length; j++) {
                if (edges[j][1] == i || edges[j][2] == i) {
                    visited[edges[j][1]] = true;
                    visited[edges[j][2]] = true;
                    count++;
                }
            }
        } else {
            return -1;
        }
    }

    return n - count;
}

void dfs(int[][] edges, boolean[] visited, int node) {
    if (visited[node]) {
        return;
    }
    visited[node] = true;

    for (int i = 0; i < edges.length; i++) {
        if ((edges[i][1] == node || edges[i][2] == node) && !visited[edges[i][1]]) {
            dfs(edges, visited, edges[i][1]);
        }
        if ((edges[i][1] == node || edges[i][2] == node) && !visited[edges[i][2]]) {
            dfs(edges, visited, edges[i][2]);
        }
    }
}
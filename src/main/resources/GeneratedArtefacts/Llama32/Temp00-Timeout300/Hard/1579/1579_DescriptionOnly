package it.cnr.iasi.saks.llmPrompter.leetCodeDemo.gen;

import org.junit.Test;
import static org.junit.Assert.*;

public class 1579_DescriptionOnly {

    @Test
    public void test_0() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}};
        assertEquals(0, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_1() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}};
        assertEquals(2, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_2() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}};
        assertEquals(3, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_3() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13}};
        assertEquals(4, maxNumEdgesToRemove(edges));
    }

    @Test
    public void test_4() {
        int[][] edges = {{1, 0, 2}, {1, 2, 3}, {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13}, {14, 15, 16}};
        assertEquals(-1, maxNumEdgesToRemove(edges));
    }
}

int maxNumEdgesToRemove(int[][] edges) {
    int n = edges.length;
    boolean[] visitedA = new boolean[n];
    boolean[] visitedB = new boolean[n];

    for (int i = 0; i < n; i++) {
        if (!visitedA[i]) {
            dfs(edges, visitedA, i);
        }
        if (!visitedB[i]) {
            dfs(edges, visitedB, i);
        }
    }

    int countA = 0;
    int countB = 0;

    for (int i = 0; i < n; i++) {
        if (visitedA[i] && !visitedB[i]) {
            countA++;
        } else if (!visitedA[i] && visitedB[i]) {
            countB++;
        }
    }

    int res = Math.min(countA, countB);
    for (int[] edge : edges) {
        if ((edge[0] == 1 || edge[0] == 3) && visitedA[edge[1]] && visitedB[edge[1]]) {
            res--;
        } else if ((edge[0] == 2 || edge[0] == 3) && visitedA[edge[1]] && !visitedB[edge[1]]) {
            res--;
        } else if ((edge[0] == 1 || edge[0] == 2) && !visitedA[edge[1]] && visitedB[edge[1]]) {
            res--;
        }
    }

    return res >= 0 ? res : -1;
}

void dfs(int[][] edges, boolean[] visited, int node) {
    visited[node] = true;

    for (int[] edge : edges) {
        if (edge[2] == node && !visited[edge[1]]) {
            dfs(edges, visited, edge[1]);
        }
        if (edge[0] == 3 && edge[1] != node && !visited[edge[1]]) {
            dfs(edges, visited, edge[1]);
        }
    }
}
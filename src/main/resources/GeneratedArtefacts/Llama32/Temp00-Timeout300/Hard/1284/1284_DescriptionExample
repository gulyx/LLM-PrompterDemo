package it.cnr.iasi.saks.llmPrompter.leetCodeDemo.gen;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class DescriptionExampleTest {

    @Test
    public void testFlipMatrix() {
        int[][] mat = {{0, 0}, {0, 1}};
        assertEquals(3, flipMatrix(mat));
    }

    @Test
    public void testZeroMatrix() {
        int[][] mat = {{0}};
        assertEquals(0, flipMatrix(mat));
    }

    @Test
    public void testFlipNotPossible() {
        int[][] mat = {{1, 0, 0}, {1, 0, 0}};
        assertEquals(-1, flipMatrix(mat));
    }

    @Test
    public void testOneCell() {
        int[][] mat = {{1}};
        assertEquals(2, flipMatrix(mat));
    }

    @Test
    public void testTwoCells() {
        int[][] mat = {{0, 1}, {1, 0}};
        assertEquals(4, flipMatrix(mat));
    }
}

public class Solution {

    public int flipMatrix(int[][] mat) {
        if (mat == null || mat.length == 0) return -1;
        int rows = mat.length;
        int cols = mat[0].length;
        boolean[][] visited = new boolean[rows][cols];
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (mat[i][j] == 1 && !visited[i][j]) {
                    queue.offer(new int[]{i, j});
                    visited[i][j] = true;
                }
            }
        }

        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] curr = queue.poll();
                if (mat[curr[0]][curr[1]] == 1) {
                    mat[curr[0]][curr[1]] = 0;
                    if (curr[0] > 0 && !visited[curr[0] - 1][curr[1]]) {
                        queue.offer(new int[]{curr[0] - 1, curr[1]});
                        visited[curr[0] - 1][curr[1]] = true;
                    }
                    if (curr[0] < rows - 1 && !visited[curr[0] + 1][curr[1]]) {
                        queue.offer(new int[]{curr[0] + 1, curr[1]});
                        visited[curr[0] + 1][curr[1]] = true;
                    }
                    if (curr[1] > 0 && !visited[curr[0]][curr[1] - 1]) {
                        queue.offer(new int[]{curr[0], curr[1] - 1});
                        visited[curr[0]][curr[1] - 1] = true;
                    }
                    if (curr[1] < cols - 1 && !visited[curr[0]][curr[1] + 1]) {
                        queue.offer(new int[]{curr[0], curr[1] + 1});
                        visited[curr[0]][curr[1] + 1] = true;
                    }
                }
            }
            steps++;
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (mat[i][j] == 1) return -1;
            }
        }
        return steps;
    }
}